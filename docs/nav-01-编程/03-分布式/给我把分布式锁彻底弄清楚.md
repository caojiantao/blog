---
title: ç»™æˆ‘æŠŠåˆ†å¸ƒå¼é”å½»åº•å¼„æ¸…æ¥š
permalink: "1711359409416"
date: '2024-03-25'
---

## é”ä»‹ç»

é”åœ¨ç¼–ç¨‹ä¸­æ˜¯ä¸€ç§åŒæ­¥æœºåˆ¶ï¼Œç”¨äºæ§åˆ¶å¯¹å…±äº«èµ„æºçš„å¹¶å‘è®¿é—®ï¼Œä»¥é˜²æ­¢å¤šä¸ªçº¿ç¨‹æˆ–è¿›ç¨‹åŒæ—¶ä¿®æ”¹åŒä¸€èµ„æºï¼Œä»è€Œé¿å…æ•°æ®ä¸ä¸€è‡´çš„é—®é¢˜ã€‚

åƒä¹‹å‰æˆ‘å†™è¿‡çš„ï¼ŒMySQL ä¸­çš„é” [MySQL å†…åŠŸâ€”â€”é”](/1693750829811/)ï¼ŒJVM ä¸­çš„é” [synchronized åº•å±‚åŸç†](/1695633585440/)ï¼ŒJDK ä¸­çš„é” [AQS åº•å±‚åŸç†](/1695712690253/)ã€‚

ä»Šå¤©ä»‹ç»çš„æ˜¯**åˆ†å¸ƒå¼é”**ï¼Œç”¨äºåœ¨åˆ†å¸ƒå¼ç³»ç»Ÿä¸­åŒæ­¥å¯¹å…±äº«èµ„æºçš„è®¿é—®ã€‚ç”±äºæ²¡æœ‰å•ä¸€çš„è¿è¡Œæ—¶ç¯å¢ƒæˆ–å†…å­˜ç©ºé—´ï¼Œä¼ ç»Ÿçš„é”æœºåˆ¶æ— æ³•ç›´æ¥åº”ç”¨ï¼Œå› æ­¤éœ€è¦ç‰¹æ®Šçš„åˆ†å¸ƒå¼é”å®ç°ã€‚

## åˆ†å¸ƒå¼é”

å…¶å®åˆ†å¸ƒå¼é”çš„æ¦‚å¿µå¾ˆå¥½ç†è§£ï¼Œæ—¢ç„¶åç«¯æœåŠ¡æ˜¯é›†ç¾¤å¼ï¼Œé‚£å°±æ‰¾åˆ°å•ä¸€çš„è¿è¡Œç¯å¢ƒè¿›è¡Œå¤„ç†å‘—ï¼›

- **æ•°æ®åº“ï¼ˆMySQLï¼‰**
  - åˆ›å»ºè¡¨ï¼Œé”æ ‡è¯†åšå”¯ä¸€ç´¢å¼•åˆ—ï¼Œæœ‰æ•ˆæœŸåˆ—ç”¨ä½œå¼‚å¸¸å…œåº•
  - åŠ é”æ—¶å¾€è¡¨é‡Œæ’å…¥è®°å½•ï¼Œé‡åˆ°å”¯ä¸€ç´¢å¼•å†²çªä¼šé˜»å¡ç­‰å¾…
  - è§£é”æ—¶å°†è®°å½•åˆ é™¤å³å¯
  - å®šæ—¶ä»»åŠ¡æ‰«ææœ‰æ•ˆæœŸéæ³•çš„è®°å½•

- **Redis**
  - åˆ©ç”¨ SET NX PX åŠ é”ï¼ŒåŸå­æ€§ + æœ‰æ•ˆæœŸ
  - è§£é”ç›´æ¥ DELETE å°±è¡Œï¼Œä½†éœ€è¦ä½¿ç”¨ Lua ä¿è¯åŸå­æ€§
  - å¯ä»¥å¼•å…¥ Watchdog å®šæ—¶ç»™é”ç»­æœŸ

- **Zookeeper**
 - åˆ©ç”¨**ä¸´æ—¶**ã€**æœ‰åº**èŠ‚ç‚¹åˆ›å»ºé”èŠ‚ç‚¹
 - ç»“åˆ Watcher æœºåˆ¶ç›‘å¬å‰ä¸€ä¸ªèŠ‚ç‚¹å˜åŒ–

é€šå¸¸çº¿ä¸Šè¿™äº›ç»„ä»¶ä¹Ÿéƒ½ä¸æ˜¯å•èŠ‚ç‚¹ï¼Œæ‰€ä»¥å¾—ä¿è¯ç»„ä»¶ä¸­çš„æ•°æ®ä¸€è‡´æ€§ã€‚ä¾‹å¦‚ Zookeeper å’Œ ETCD æ˜¯åŸºäº CP çš„å¼ºä¸€è‡´æ€§ï¼ŒRedis æ˜¯åŸºäº AP çš„ï¼Œéœ€è¦ç”¨åˆ° RedLock ç®—æ³•ã€‚

## Redis ç‰ˆ

### åŸºç¡€

ç”¨ä¸‹é¢è¿™ä¸ªä¾‹å­æ¥ç†è§£ Redis åˆ†å¸ƒå¼é”å†é€‚åˆä¸è¿‡äº†ï¼›

```java
@Slf4j
@Service
public class LockService {

    @Autowired
    private StringRedisTemplate redisTemplate;

    /**
     * è§£é” LUA è„šæœ¬
     */
    private static final RedisScript<Long> RELEASE_SCRIPT = new DefaultRedisScript<>(
            "if redis.call('get', KEYS[1]) == ARGV[1] " +
                    "then return redis.call('del', KEYS[1]) " +
                    "else return 0 " +
                    "end",
            Long.class
    );

    /**
     * åŠ é”
     */
    public Boolean tryLock(String key, String value, long expireTime, TimeUnit expireUnit) {
        Boolean result = redisTemplate.opsForValue().setIfAbsent(key, value, expireTime, expireUnit);
        log.info("act=tryLock key={} value={} expireTime={} expireUnit={} result={}", key, value, expireTime, expireUnit, result);
        return result;
    }

    /**
     * è§£é”
     */
    public void release(String key, String value) {
        Long result = redisTemplate.execute(RELEASE_SCRIPT, Collections.singletonList(key), value);
        log.info("act=release key={} value={} result={}", key, value, result);
    }
}
```

åŠ é”éœ€è¦æ³¨æ„ä¸¤ç‚¹ï¼Œä¸€éœ€è¦è®¾ç½®è¿‡æœŸæ—¶é—´ï¼ŒäºŒéœ€è¦è®¾ç½®å”¯ä¸€æ ‡è¯†ã€‚è§£é”éœ€è¦æ³¨æ„ç”¨ LUA è„šæœ¬ä¿è¯åŸå­æ€§ï¼Œæ ¡éªŒå”¯ä¸€æ ‡è¯†è§£é”ã€‚

### é˜»å¡å¼åŠ é”

```java
    @Autowired
    private RedisMessageListenerContainer redisMessageListenerContainer;
    
    /**
     * é˜»å¡å¼åŠ é”
     */
    public Boolean lock(String key, String value, long expireTime, TimeUnit expireUnit, long waitTime, TimeUnit waitUnit) {
        long deadline = System.currentTimeMillis() + waitUnit.toMillis(waitTime);
        log.info("act=lock key={} type=start value={} expireTime={} expireUnit={} waitTime={} waitUnit={} deadline={}", key, value, expireTime, expireUnit, waitTime, waitUnit, deadline);
        Thread thread = Thread.currentThread();
        MessageListener messageListener = (message, pattern) -> {
            log.info("act=onRedisMessageListener message={} pattern={}", message, pattern);
            LockSupport.unpark(thread);
        };
        // ä»¥ key ä¸º topic è®¢é˜…
        ChannelTopic channelTopic = new ChannelTopic(key);
        while (true) {
            if (deadline < System.currentTimeMillis()) {
                redisMessageListenerContainer.removeMessageListener(messageListener, channelTopic);
                log.info("act=lock key={} type=end result=false", key);
                return false;
            }
            Boolean locked = tryLock(key, value, expireTime, expireUnit);
            if (locked) {
                redisMessageListenerContainer.removeMessageListener(messageListener, channelTopic);
                log.info("act=lock key={} type=end result=true", key);
                return true;
            }
            redisMessageListenerContainer.addMessageListener(messageListener, channelTopic);
            LockSupport.parkUntil(deadline);
        }
    }
```

è¿™é‡Œé€šè¿‡ Redis çš„ ChannelTopic åŠŸèƒ½æ¥ç›‘å¬é”®çš„å˜æ›´ï¼Œç»“åˆä¸Šè¿°çš„ tryLock æ–¹æ³•å®ç°ä¸€ä¸ªé˜»å¡å¼åŠ é”æ–¹æ³•ã€‚

å€¼å¾—æ³¨æ„è¿™é‡Œä½¿ç”¨ parkUntil é˜»å¡çº¿ç¨‹ï¼Œå¹¶ä¸æ˜¯æ¯æ¬¡å”¤é†’éƒ½èƒ½ tryLock æˆåŠŸï¼Œæ‰€ä»¥æ”¾åœ¨ä¸€ä¸ª while ä¸­å¤„ç†ã€‚

> å…¶å®è¿™é‡Œåœ¨ parkUntil ä¹‹å‰éœ€è¦äºŒæ¬¡æ£€æŸ¥é”å·²ç»è¢«é‡Šæ”¾ï¼Œå¯èƒ½ç”±äºå¹¶å‘é—®é¢˜é”åˆšé‡Šæ”¾å†è¢«è®¢é˜…ä¸Šã€‚

### è‡ªåŠ¨ç»­æœŸ

å­˜åœ¨ä¸šåŠ¡æ‰§è¡Œè€—æ—¶æ¯”é”®è¿‡æœŸæ—¶é—´è¿˜é•¿çš„æƒ…å†µï¼Œæ­¤æ—¶å…¶ä»–è¯·æ±‚ä¹Ÿèƒ½åŠ é”æˆåŠŸï¼Œæ‰€ä»¥éœ€è¦ç»™æ‰§è¡Œä¸­çš„é”®ç»­æœŸï¼›

```java
    private static final ScheduledExecutorService TIMER = Executors.newScheduledThreadPool(64);
    
    /**
     * ç»­æœŸ LUA è„šæœ¬
     */
    private static final RedisScript<Long> RENEW_SCRIPT = new DefaultRedisScript<>(
            "if redis.call('get', KEYS[1]) == ARGV[1] then " +
                    "return redis.call('pexpire', KEYS[1], ARGV[2]) " +
                    "else " +
                    "return 0 " +
                    "end",
            Long.class
    );

    /**
     * å°è¯•åŠ é”
     */
    public Boolean tryLock(String key, String value, long expireTime, TimeUnit expireUnit) {
        Boolean result = redisTemplate.opsForValue().setIfAbsent(key, value, expireTime, expireUnit);
        if (result) {
            renewExpiration(key, value, expireTime, expireUnit);
        }
        log.info("act=tryLock key={} value={} expireTime={} expireUnit={} result={}", key, value, expireTime, expireUnit, result);
        return result;
    }

    /**
     * è‡ªåŠ¨ç»­æœŸ
     */
    private void renewExpiration(String key, String value, long expireTime, TimeUnit expireUnit) {
        TIMER.schedule(() -> {
            Long expire = redisTemplate.getExpire(key, TimeUnit.MILLISECONDS);
            if (Objects.isNull(expire) || expire <= 0) {
                log.info("act=renewExpiration key={} value={} type=stop", key, value);
                return;
            }
            long newExpire = expire << 1;
            Long result = redisTemplate.execute(RENEW_SCRIPT, Collections.singletonList(key), value, String.valueOf(newExpire));
            if (result == 0) {
                log.info("act=renewExpiration key={} value={} type=stop", key, value);
            } else {
                log.info("act=renewExpiration key={} value={} type=consume", key, value);
                renewExpiration(key, value, newExpire, TimeUnit.MILLISECONDS);
            }
        }, expireTime >> 1, expireUnit);
    }
```

### å¯é‡å…¥

åŠ é”çš„æ•°æ®ç»“æ„æ¢æˆ HASHï¼ŒFIELD ä¸ºå½“å‰è¯·æ±‚çº¿ç¨‹æ ‡è¯†ï¼ŒVALUE ä¸ºåŠ é”çš„æ¬¡æ•°ã€‚æ³¨æ„åŒæ ·éœ€è¦ç”¨ LUA è„šæœ¬ä¿è¯æ“ä½œåŸå­æ€§ï¼›

```java
    @Autowired
    private StringRedisTemplate redisTemplate;

    @Autowired
    private RedisMessageListenerContainer redisMessageListenerContainer;

    private static final ScheduledExecutorService TIMER = Executors.newScheduledThreadPool(64);

    /**
     * å®¢æˆ·ç«¯å”¯ä¸€æ ‡è¯†
     */
    private static final String CLIENT_ID = UUID.randomUUID().toString();

    /**
     * åŠ é” LUA è„šæœ¬
     */
    private static final RedisScript<Long> LOCK_SCRIPT = new DefaultRedisScript<>(
            "if ((redis.call('exists', KEYS[1]) == 0) or (redis.call('hexists', KEYS[1], ARGV[1]) == 1)) then " +
                    "local rst  = redis.call('hincrby', KEYS[1], ARGV[1], 1) " +
                    "redis.call('pexpire', KEYS[1], ARGV[2]) " +
                    "return rst " +
                    "end " +
                    "return 0 ",
            Long.class
    );

    /**
     * è§£é” LUA è„šæœ¬
     */
    private static final RedisScript<Long> RELEASE_SCRIPT = new DefaultRedisScript<>(
            "local counter = redis.call('hincrby', KEYS[1], ARGV[1], -1)" +
                    "if (counter == 0) then " +
                    "redis.call('del', KEYS[1]) " +
                    "end " +
                    "return redis.call('ttl', KEYS[1]) ",
            Long.class
    );

    private static final RedisScript<Long> RENEW_SCRIPT = new DefaultRedisScript<>(
            "local val = redis.call('hget', KEYS[1], ARGV[1]); " +
                    "if ((val ~= false) and (tonumber(val) > 0)) then " +
                    "return redis.call('pexpire', KEYS[1], ARGV[2]) " +
                    "else " +
                    "return 0 " +
                    "end ",
            Long.class
    );


    private String getThreadId() {
        return CLIENT_ID + ":" + Thread.currentThread().getName();
    }

    /**
     * å°è¯•åŠ é”
     */
    public Boolean tryLock(String key, long expireTime, TimeUnit expireUnit) {
        Long result = redisTemplate.execute(LOCK_SCRIPT, Collections.singletonList(key), getThreadId(), String.valueOf(expireUnit.toMillis(expireTime)));
        log.info("act=tryLock key={} thread={} expireTime={} expireUnit={} result={}", key, getThreadId(), expireTime, expireUnit, result);
        if (result == 1) {
            // åªæœ‰ç¬¬ä¸€æ¬¡åŠ é”ä¼šè‡ªåŠ¨ç»­æœŸï¼Œé‡å…¥æ—¶ä¸å†é‡å¤ç»­æœŸ
            renewExpiration(key, getThreadId(), expireTime, expireUnit);
        }
        return result > 0;
    }

    /**
     * è‡ªåŠ¨ç»­æœŸ
     */
    private void renewExpiration(String key, String value, long expireTime, TimeUnit expireUnit) {
        TIMER.schedule(() -> {
            Long expire = redisTemplate.getExpire(key, TimeUnit.MILLISECONDS);
            if (Objects.isNull(expire) || expire <= 0) {
                log.info("act=renewExpiration key={} value={} type=stop", key, value);
                return;
            }
            long newExpire = expire << 1;
            Long result = redisTemplate.execute(RENEW_SCRIPT, Collections.singletonList(key), value, String.valueOf(newExpire));
            if (result == 0) {
                log.info("act=renewExpiration key={} value={} type=stop", key, value);
            } else {
                log.info("act=renewExpiration key={} value={} type=consume", key, value);
                renewExpiration(key, value, newExpire, TimeUnit.MILLISECONDS);
            }
        }, expireTime >> 1, expireUnit);
    }

    /**
     * é˜»å¡å¼åŠ é”
     */
    public Boolean lock(String key, long expireTime, TimeUnit expireUnit, long waitTime, TimeUnit waitUnit) {
        long deadline = System.currentTimeMillis() + waitUnit.toMillis(waitTime);
        log.info("act=lock key={} type=start expireTime={} expireUnit={} waitTime={} waitUnit={} deadline={}", key, expireTime, expireUnit, waitTime, waitUnit, deadline);
        Thread thread = Thread.currentThread();
        MessageListener messageListener = (message, pattern) -> {
            log.info("act=onRedisMessageListener message={} pattern={}", message, pattern);
            LockSupport.unpark(thread);
        };
        // ä»¥ key ä¸º topic è®¢é˜…
        ChannelTopic channelTopic = new ChannelTopic(key);
        while (true) {
            if (deadline < System.currentTimeMillis()) {
                redisMessageListenerContainer.removeMessageListener(messageListener, channelTopic);
                log.info("act=lock key={} type=end result=false", key);
                return false;
            }
            Boolean locked = tryLock(key, expireTime, expireUnit);
            if (locked) {
                redisMessageListenerContainer.removeMessageListener(messageListener, channelTopic);
                log.info("act=lock key={} type=end result=true", key);
                return true;
            }
            redisMessageListenerContainer.addMessageListener(messageListener, channelTopic);
            LockSupport.parkUntil(deadline);
        }
    }

    /**
     * è§£é”
     */
    public void unlock(String key) {
        Long result = redisTemplate.execute(RELEASE_SCRIPT, Collections.singletonList(key), getThreadId());
        redisTemplate.convertAndSend(key, "");
        log.info("act=unlock key={} value={} result={}", key, getThreadId(), result);
    }
```

### å…¬å¹³é”

å…¬å¹³é”éœ€è¦æŒ‰è¯·æ±‚é¡ºåºåŠ é”ï¼Œæ‰€ä»¥è®¢é˜… TOPIC æ—¶éœ€è¦æ”¹é€ ä¸‹ï¼Œæ”¹é€ æˆè®¢é˜…å‰ä¸€ä¸ªåŠ é”è¯·æ±‚çš„ TOPICã€‚

æ‰€ä»¥éœ€è¦ä¸€ä¸ª LIST å­˜å‚¨åŠ é”é¡ºåºï¼Œä½†æ˜¯ç”±äºåŠ é”è¯·æ±‚ä¼šæœ‰å¼‚å¸¸æƒ…å†µæ–­å¼€ï¼Œæ‰€ä»¥æ¯ä¸ªåŠ é”çš„è¯·æ±‚ä¹Ÿåº”è¯¥è®¾ç½®è¿‡æœŸæ—¶é—´ï¼Œç»“åˆ WATCH DOG æœºåˆ¶ã€‚

ç„¶ååœ¨è§£é”æ‰¾åˆ°æœ€æ—©çš„æœ‰æ•ˆè¯·æ±‚è®°å½•è¿›è¡Œè§£é”å³å¯ã€‚

> æš‚æ—¶ä¸å»å†™äº†ï¼ŒLUA è°ƒèµ·æ¥å¾—æœ‰ç‚¹ç´¯ğŸ˜­ğŸ˜­
